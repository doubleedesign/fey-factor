import readline from 'readline';
import chalk from 'chalk';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { exec } from 'child_process';
import { InterfaceTypeDefinitionNode, ObjectTypeDefinitionNode, visit } from 'graphql';
import gql from 'graphql-tag';
import ts from 'typescript';
import difference from 'lodash/difference';
import capitalize from 'lodash/capitalize';
import { getSupertypeOfSubtype, getTypeForContainerType, typeFormatToDbTableNameFormat } from './utils';

const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout
});

const typeNames = [];
const template = readFileSync('./utils/_resolver-template.ts', 'utf8');

generateResolvers().then();

async function generateResolvers() {
	console.log(chalk.red('==================================================================================='));
	console.log(chalk.yellow('This script will generate skeleton code (with assumed likely function calls) \n' +
		'for the resolvers for the types generated by the "npm run generate" script.'));
	console.log(chalk.red('This is a destructive operation that will overwrite the existing resolver files.'));
	const confirmed = await confirm('Do you want to continue?');
	if (!confirmed) process.exit(0);

	// Parse the GraphQL schema
	const gqlTypes = readFileSync('./src/generated/typeDefs.graphql', 'utf8');
	const parsedSchema = gql`${gqlTypes}`;

	// Parse the TypeScript types
	const tsTypes = readFileSync('./src/generated/source-types.ts', 'utf8');
	const tsSourceFile = ts.createSourceFile(
		'types.ts',
		tsTypes,
		ts.ScriptTarget.Latest,
		true
	);

	// Create a file for each GraphQL type based on the template and insert likely resolver functions
	// (but do not create separate files for {Type}Container types - they will be handled in their associated type)
	visit(parsedSchema, {
		ObjectTypeDefinition(node) {
			try {
				typeNames.push(node.name.value);
				if(!node.name.value.endsWith('Container')) {
					generateResolverFile(node, tsSourceFile, parsedSchema);
				}
			}
			catch (error) {
				console.error(chalk.red(`Error generating resolver file for ${node.name.value}: ${error}`));
			}
		},
		InterfaceTypeDefinition(node) {
			try {
				typeNames.push(node.name.value);
				if(!node.name.value.endsWith('Container')) {
					generateResolverFile(node, tsSourceFile, parsedSchema);
				}
			}
			catch (error) {
				console.error(chalk.red(`Error generating resolver file for ${node.name.value}: ${error}`));
			}
		},
	});

	// Run eslint on the generated files
	exec('eslint --fix ./src/resolvers/**/*.ts', (error, stdout, stderr) => {
		if (error || stderr) {
			console.error(chalk.red(error || stderr));
		}

		console.log(chalk.green('Successfully linted and formatted resolver files'));
	});

	// Generate the updated index file
	let indexContent = 'import merge from \'lodash/merge\';\n';
	let exportLine = 'export default merge({}';
	typeNames.forEach(typeName => {
		if(!typeName.endsWith('Container')) {
			indexContent += `import ${typeName}Resolvers from './${typeName}';\n`;
			exportLine += `, ${typeName}Resolvers`;
		}
	});
	indexContent += `\n\n${exportLine})`;
	writeFileSync('./src/resolvers/index.ts', indexContent);

	rl.close();
}


/**
 * Function to generate a resolver file for a given GraphQL type
 * @param node
 * @param tsSourceFile
 */
function generateResolverFile(node: ObjectTypeDefinitionNode | InterfaceTypeDefinitionNode, tsSourceFile: ts.SourceFile, parsedSchema) {
	const typeName = node.name.value;
	const filename = `./src/resolvers/${typeName}.ts`;
	const supertype = getSupertypeOfSubtype(typeName);
	const groupName = typeFormatToDbTableNameFormat(supertype || typeName);

	let fileContent = template
		.replace('// eslint-disable-next-line @typescript-eslint/ban-ts-comment', '')
		.replace('// @ts-nocheck', '')
		.replace('db.getTemplate', `db.${groupName}.get${typeName}`)
		.replaceAll('Template', typeName)
		.replaceAll('template', typeName.toLowerCase());


	if(node.kind === 'ObjectTypeDefinition') {
		// The fields in the TS type are generated directly from the database, so should be covered by the initial Query
		// Get the fields that are in the GQL type but not the TS type, because those need to be added to the second section
		const tsFields = getInterfaceFields(typeName, tsSourceFile);
		const gqlFields = node.fields.map(field => field.name.value);

		const diff = difference(gqlFields, tsFields);
		if (diff.length > 0) {
			const resolverFunctions = diff.map(field => {
				const functionName = `db.${groupName}.get${capitalize(field)}For${capitalize(typeName)}`;
				const arg = field === 'id' ? 'id' : `${typeName.toLowerCase()}.id`;

				return `${field}: async (${typeName.toLowerCase()}: ${typeName}) => {\nreturn ${functionName}(${arg});\n},`;
			});

			// TODO: These need to resolve whole extended objects, not just containers
			fileContent = fileContent.replace(`${typeName}: {}`, `${typeName}: {\n ${resolverFunctions.join('\n')} \n}`);
		}
	}

	if(node.kind === 'InterfaceTypeDefinition') {
		// Remove the query function for the interface
		fileContent = removeQueryBlock(fileContent);
		// Add comments to add the resolver functions
		fileContent = fileContent.replace(`${typeName}: {}`, `${typeName}: {
			__resolveType(${typeName.toLowerCase()}) {
				// TODO Add logic here to determine the subtype to return
			}
			// TODO Add any additional resolvers here
		}`);
		console.log(chalk.yellow(`Please add resolver functions for the abstract interface ${typeName}`));
	}

	if(doesTypeExist(`${typeName}Container`, parsedSchema)) {
		// TODO: return container fields correctly
		fileContent = fileContent.replace(`${typeName}Container: {}`, `${typeName}Container: {
			${typeName.toLowerCase()}: async (id) => {
				return db.${groupName}.get${typeName}(id);
			}
		}`);
	}
	else {
		fileContent = fileContent.replace(`${typeName}Container: {}`, '');
	}

	try {
		writeFileSync(filename, fileContent);
		if(existsSync(filename)) {
			console.log(chalk.green(`Successfully created resolver file for ${typeName} at ${filename}`));
		}
		else {
			console.error(chalk.red(`Error creating resolver file for ${typeName}`));
		}
	}
	catch (error) {
		console.error(chalk.red(`Error creating resolver file for ${typeName}: ${error}`));
	}
}


/**
 * Function to find an interface by name in the TypeScript types file and get its fields
 * @param sourceFile
 * @param interfaceName
 */
function getInterfaceFields(interfaceName: string, sourceFile: ts.SourceFile, ) {
	const fields = [];

	function visit(node) {
		// Check if the node is an interface declaration
		if (ts.isInterfaceDeclaration(node) && node.name.text === interfaceName) {
			node.members.forEach(member => {
				if (ts.isPropertySignature(member) && member.name) {
					fields.push(member.name.getText());
				}
			});
		}
		ts.forEachChild(node, visit);
	}

	visit(sourceFile);

	return fields;
}

/**
 * Function to remove the Query block from a resolver if it is not needed
 * @param content
 */
function removeQueryBlock(content) {
	const regex = /Query:\s*\{([^{}]*|\{[^{}]*\})*\},\s*\n?/g;
	let match;

	while ((match = regex.exec(content)) !== null) {
		content = content.replace(match[0], '');
	}

	return content.trim();
}

/**
 * Function to check if a type exists in the parsed schema
 * @param typeName
 * @param parsedSchema
 */
function doesTypeExist(typeName: string, parsedSchema): boolean {
	let typeExists = false;

	visit(parsedSchema, {
		ObjectTypeDefinition(node) {
			if (node.name.value === typeName) {
				typeExists = true;
			}
		},
	});

	return typeExists;
}

/**
 * Function to ask a yes/no question in the generator
 * @param question
 */
function confirm(question: string) {
	return new Promise((resolve) => {
		rl.question(chalk.cyan(`${question} (y/n): \n`), (answer) => {
			resolve(answer.toLowerCase() === 'y');
		});
	});
}
