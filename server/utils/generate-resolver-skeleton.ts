import readline from 'readline';
import chalk from 'chalk';
import { readFileSync, writeFileSync } from 'fs';
import { exec } from 'child_process';
import { InterfaceTypeDefinitionNode, ObjectTypeDefinitionNode, visit } from 'graphql';
import gql from 'graphql-tag';
import ts from 'typescript';
import difference from 'lodash/difference';
import capitalize from 'lodash/capitalize';

const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout
});

const typeNames = [];
const template = readFileSync('./utils/_resolver-template.ts', 'utf8');

generateResolvers().then();

async function generateResolvers() {
	console.log(chalk.red('==================================================================================='));
	console.log(chalk.yellow('This script will generate skeleton code (with assumed likely function calls) \nfor the resolvers for the types generated by the "npm run generate" script.'));
	console.log(chalk.red('This is a destructive operation that will overwrite the existing resolver files.'));
	const confirmed = await confirm('Do you want to continue?');
	if (!confirmed) process.exit(0);

	// Parse the GraphQL schema
	const gqlTypes = readFileSync('./src/generated/typeDefs.graphql', 'utf8');
	const parsedSchema = gql`${gqlTypes}`;

	// Parse the TypeScript types
	const tsTypes = readFileSync('./src/generated/source-types.ts', 'utf8');
	const tsSourceFile = ts.createSourceFile(
		'types.ts',
		tsTypes,
		ts.ScriptTarget.Latest,
		true
	);

	// Create a file for each GraphQL type based on the template and insert likely resolver functions
	// (but do not create separate files for {Type}Item types - they will be handled in their associated type)
	visit(parsedSchema, {
		ObjectTypeDefinition(node) {
			if(node.name.value.includes('Item')) return;
			typeNames.push(node.name.value);
			generateResolverFile(node, tsSourceFile);
		},
		InterfaceTypeDefinition(node) {
			if(node.name.value.includes('Item')) return;
			typeNames.push(node.name.value);
			generateResolverFile(node, tsSourceFile);
		},
	});

	// Run eslint on the generated files
	exec('eslint --fix ./src/resolvers/**/*.ts', (error, stdout, stderr) => {
		if (error || stderr) {
			console.error(chalk.red(error || stderr));
		}

		console.log(chalk.green('Successfully linted and formatted resolver files'));
	});

	// Generate the updated index file
	let indexContent = 'import merge from \'lodash/merge\';\n';
	let exportLine = 'export default merge({}';
	typeNames.forEach(typeName => {
		indexContent += `import ${typeName}Resolvers from './${typeName}';\n`;
		exportLine += `, ${typeName}Resolvers`;
	});
	indexContent += `\n\n${exportLine})`;
	writeFileSync('./src/resolvers/index.ts', indexContent);

	rl.close();
}


/**
 * Function to generate a resolver file for a given GraphQL type
 * @param node
 * @param tsSourceFile
 */
function generateResolverFile(node: ObjectTypeDefinitionNode | InterfaceTypeDefinitionNode, tsSourceFile: ts.SourceFile) {
	const typeName = node.name.value;
	const filename = `./src/resolvers/${typeName}.ts`;
	let fileContent = template
		.replace('// eslint-disable-next-line @typescript-eslint/ban-ts-comment', '')
		.replace('// @ts-nocheck', '')
		.replaceAll('Template', typeName)
		.replaceAll('template', typeName.toLowerCase());

	if(node.kind === 'ObjectTypeDefinition') {
		// The fields in the TS type are generated directly from the database, so should be covered by the initial Query
		// Get the fields that are in the GQL type but not the TS type, because those need to be added to the second section
		const tsFields = getInterfaceFields(typeName, tsSourceFile);
		const gqlFields = node.fields.map(field => field.name.value);
		const diff = difference(gqlFields, tsFields);
		if (diff.length > 0) {
			const resolverFunctions = diff.map(field => {
				const functionName = `db.get${capitalize(field)}For${capitalize(typeName)}`;
				const arg = field === 'id' ? 'id' : `${typeName.toLowerCase()}.id`;

				return `${field}: async (${typeName.toLowerCase()}: ${typeName}) => {\nreturn ${functionName}(${arg});\n},`;
			});

			fileContent = fileContent.replace(`${typeName}: {}`, `${typeName}: {\n ${resolverFunctions.join('\n')} \n},`);
		}
	}

	if(node.kind === 'InterfaceTypeDefinition') {
		// Remove the query function for the interface
		fileContent = removeQueryBlock(fileContent);
		// Add a comment to add the resolver functions
		fileContent = fileContent.replace(`${typeName}: {}`, `${typeName}: {\n// TODO Add resolvers here\n},`);
		console.log(chalk.yellow(`Please add resolver functions for the abstract interface ${typeName}`));
	}

	if(typeNames.includes(`${typeName}Item`)) {
		// TODO What to replace this with?
		fileContent = fileContent.replace(`${typeName}Item: {}`, `${typeName}Item: {}`);
	}
	else {
		// Remove the Item type block if that type does not exist
		fileContent = fileContent.replace(`${typeName}Item: {}`, '');
	}

	writeFileSync(filename, fileContent);
	console.log(chalk.green(`Successfully created resolver file for ${typeName}`));
}


/**
 * Function to find an interface by name in the TypeScript types file and get its fields
 * @param sourceFile
 * @param interfaceName
 */
function getInterfaceFields(interfaceName: string, sourceFile: ts.SourceFile, ) {
	const fields = [];

	function visit(node) {
		// Check if the node is an interface declaration
		if (ts.isInterfaceDeclaration(node) && node.name.text === interfaceName) {
			node.members.forEach(member => {
				if (ts.isPropertySignature(member) && member.name) {
					fields.push(member.name.getText());
				}
			});
		}
		ts.forEachChild(node, visit);
	}

	visit(sourceFile);

	return fields;
}

function removeQueryBlock(content) {
	const regex = /Query:\s*\{([^{}]*|\{[^{}]*\})*\},/g;
	let match;

	while ((match = regex.exec(content)) !== null) {
		content = content.replace(match[0], '');
	}

	return content;
}


function confirm(question: string) {
	return new Promise((resolve) => {
		rl.question(`${question} (y/n): `, (answer) => {
			resolve(answer.toLowerCase() === 'y');
		});
	});
}
